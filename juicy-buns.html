<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>流汁汤包 · Juicy Soup Dumplings</title>
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Helvetica Neue', Arial, 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #e55050 0%, #5331c1 100%);
            color: #ffffff;
            display: flex;
            align-items: stretch;
            justify-content: center;
            padding: 90px clamp(24px, 6vw, 80px) 48px;
        }

        #particle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }

        .hamburger-menu {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .hamburger-btn {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
        }

        .hamburger-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }

        .hamburger-line {
            width: 20px;
            height: 2px;
            background: white;
            margin: 2px 0;
            transition: all 0.3s ease;
        }

        .hamburger-btn.active .hamburger-line:nth-child(1) {
            transform: rotate(45deg) translate(5px, 5px);
        }

        .hamburger-btn.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }

        .hamburger-btn.active .hamburger-line:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -6px);
        }

        .menu-dropdown {
            position: absolute;
            top: 60px;
            right: 0;
            background: rgba(255,255,255,0.15);
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: 15px;
            padding: 10px;
            backdrop-filter: blur(12px);
            box-shadow: 0 18px 40px rgba(0,0,0,0.2);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            min-width: 180px;
        }

        .menu-dropdown.show {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .menu-item {
            display: block;
            color: white;
            text-decoration: none;
            padding: 12px 16px;
            margin: 5px 0;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 16px;
            text-align: center;
        }

        .menu-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        main {
            display: flex;
            width: min(1200px, 100%);
            gap: clamp(24px, 5vw, 56px);
        }

        .text-panel {
            flex: 0 0 38%;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 24px;
            padding: clamp(24px, 4vw, 48px);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(16px);
        }

        .text-panel h1 {
            margin: 0 0 24px;
            font-size: clamp(32px, 3.4vw, 44px);
            line-height: 1.1;
            letter-spacing: 0.08em;
            color: #ffffff;
        }

        .text-panel h1 span {
            display: block;
            font-size: clamp(16px, 1.6vw, 18px);
            letter-spacing: 0.35em;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.75);
            margin-top: 10px;
        }

        .text-panel p {
            margin: 18px 0;
            font-size: clamp(15px, 1.4vw, 18px);
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            text-align: justify;
        }

        /*
         * .media-panel 样式解读：
         * 这是媒体内容的容器。它被设置为 Flex 容器，用于居中其内部的 #mediaCanvas。
         * `overflow: hidden;` 确保任何超出容器边界的内容（例如浮动动画的边缘）不会显示出来，保持布局整洁。
         * `perspective: 1400px;` 为其子元素（特别是 #mediaCanvas 内部的元素）创建 3D 视角效果，
         * 这对于 `translateZ` 这样的 3D 变换是必需的，使得浮动动画看起来有深度。
         */
        .media-panel {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: clamp(360px, 48vw, 540px);
            overflow: hidden;
            background: none;
            box-shadow: none;
            border: none;
            perspective: 1400px;
        }

        /*
         * #mediaCanvas 样式解读：
         * 这是实际承载所有图片和视频的画布。它也是一个 Flex 容器，
         * `flex-wrap: wrap;` 允许媒体元素在空间不足时自动换行，实现平铺效果。
         * `gap: 10px;` 在媒体元素之间创建间隔。
         * `padding: 10px;` 为整个媒体画布提供内边距。
         * `transform-style: preserve-3d;` 确保其子元素的 3D 变换（如浮动动画）能够正确地在 3D 空间中呈现。
         * 如果你想调整媒体元素的排列方式，可以修改这里的 Flexbox 属性，例如 `justify-content` 或 `align-items`。
         */
        #mediaCanvas {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: clamp(360px, 48vw, 540px);
            display: flex;
            align-items: center;
            justify-content: center;
            transform-style: preserve-3d;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
        }

        /*
         * .floating-media 样式解读：
         * 这是每个图片或视频元素的基础样式。
         * `position: relative;` 和 `top: auto; left: auto;` 确保元素根据 Flexbox 布局而非绝对定位。
         * `box-shadow` 增加了视觉深度。
         * `animation: floatAnimation 6s ease-in-out infinite;` 应用了名为 `floatAnimation` 的动画。
         * `6s` 是动画持续时间，`ease-in-out` 是动画速度曲线（开始和结束慢，中间快），`infinite` 表示无限循环。
         * 如果你想改变浮动动画的速度或方式，可以修改这里。
         */
        .floating-media {
            position: relative;
            top: auto;
            left: auto;
            border-radius: 22px;
            object-fit: cover;
            filter: saturate(1.05) contrast(1.03);
            will-change: transform, opacity;
            pointer-events: none;
            border: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transform-origin: center;
            animation: floatAnimation 6s ease-in-out infinite;
        }

        /*
         * @keyframes floatAnimation 样式解读：
         * 这是定义浮动动画的关键帧。
         * `0%` 和 `100%` 状态下，`translateZ(0px)` 表示元素在 Z 轴上没有位移，即在原始位置。
         * `50%` 状态下，`translateZ(40px)` 表示元素在 Z 轴上向前移动 40 像素，创建“浮起”的效果。
         * 你可以通过修改 `translateZ` 的值来调整浮动的高度，或者添加 `translateY` 来实现垂直方向的浮动。
         * 改变关键帧的百分比可以调整动画的节奏。
         */
        @keyframes floatAnimation {
            0% {
                transform: translateZ(0px);
            }
            50% {
                transform: translateZ(40px);
            }
            100% {
                transform: translateZ(0px);
            }
        }

        video.floating-media {
            background: transparent;
        }

        .overlay-gradient {
            display: none;
        }

        @media (max-width: 960px) {
            body {
                padding: 110px clamp(16px, 6vw, 32px) 40px;
            }

            main {
                flex-direction: column;
                align-items: stretch;
            }

            .text-panel {
                flex-basis: auto;
            }

            .media-panel {
                min-height: 380px;
            }
        }

        @media (max-width: 600px) {
            .hamburger-menu {
                top: 16px;
                right: 16px;
            }

            .menu-dropdown {
                right: 0;
            }

            .text-panel {
                padding: clamp(20px, 6vw, 36px);
            }
        }
    </style>
</head>
<body>
    <div id="particle-container"></div>
    <div class="hamburger-menu">
        <button class="hamburger-btn" onclick="toggleMenu()">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </button>
        <div class="menu-dropdown" id="menuDropdown">
            <a href="index.html" class="menu-item">Home</a>
            <a href="about.html" class="menu-item">About</a>
            <a href="food.html" class="menu-item">Food</a>
            <a href="exhibition.html" class="menu-item">Exhibition</a>
            <a href="https://studio.example.com" class="menu-item" target="_blank">Studio</a>
            <a href="https://instagram.com/futuretensehk" class="menu-item" target="_blank">Instagram</a>
        </div>
    </div>
    <main>
        <section class="text-panel">
            <h1>流汁湯包<span>Juicy Buns</span></h1>
            <p>「輕輕提，慢慢移，先開窗，後喝湯。」這句順口溜，精準地概括了品嚐流汁湯包的精髓。流汁湯包，一道源自中國江南地區的傳統名點，以其皮薄、餡大、湯多、味鮮的特點，贏得了無數食客的青睞。 </p>
            <p>我們邀請到了小李（化名），分享了他對流汁湯包的見解以及如何使用AI進行記錄變化與創新的過程。 </p>
            <p>"Gently lift, move slowly, first open the window, then drink the soup." This catchy phrase accurately summarizes the essence of tasting juicy soup dumplings. Juicy soup dumplings, a traditional famous snack from the Jiangnan region of China, have won the favor of countless diners with their thin skin, large filling, rich soup, and delicious taste.</p>
        </section>
        <section class="media-panel">
            <div id="mediaCanvas"></div>
            <div class="overlay-gradient"></div>
        </section>
    </main>

    <script>
        function toggleMenu() {
            const hamburgerBtn = document.querySelector('.hamburger-btn');
            const menuDropdown = document.getElementById('menuDropdown');

            if (!hamburgerBtn || !menuDropdown) return;

            hamburgerBtn.classList.toggle('active');
            menuDropdown.classList.toggle('show');
        }

        (function () {
            const hamburgerMenu = document.querySelector('.hamburger-menu');
            const menuDropdown = document.getElementById('menuDropdown');
            const hamburgerBtn = document.querySelector('.hamburger-btn');

            if (!hamburgerMenu || !menuDropdown || !hamburgerBtn) {
                return;
            }

            document.addEventListener('click', function (event) {
                if (!hamburgerMenu.contains(event.target)) {
                    menuDropdown.classList.remove('show');
                    hamburgerBtn.classList.remove('active');
                }
            });

            hamburgerMenu.addEventListener('click', function (event) {
                event.stopPropagation();
            });
        })();

        /*
         * mediaItems 数组解读：
         * 这个数组定义了所有要显示在 #mediaCanvas 上的媒体资源。
         * 每个对象包含：
         * - `type`: 媒体类型，可以是 'image' 或 'video'。
         * - `src`: 媒体文件的路径。你可以修改这些路径来更换图片或视频。
         * - `alt`: 媒体的替代文本，用于无障碍访问和图片加载失败时显示。
         * 如果你想添加更多媒体，只需在这个数组中添加新的对象即可。
         */
        const mediaItems = [
            { type: 'image', src: 'food/流汁汤包/1.png', alt: '1' },
            { type: 'image', src: 'food/流汁汤包/2.png', alt: '2' },
            { type: 'image', src: 'food/流汁汤包/3.png', alt: '3' },
            { type: 'image', src: 'food/流汁汤包/4.png', alt: '4' },
            { type: 'image', src: 'food/流汁汤包/5.png', alt: '5' },
            { type: 'video', src: 'food/流汁汤包/fen_DJI_0003.mp4', alt: '2' },
            { type: 'video', src: 'food/流汁汤包/ya_DJI_0006.mp4', alt: '3' },
            { type: 'video', src: 'food/流汁汤包/bao_DJI_0044.mp4', alt: '3' },
            { type: 'video', src: 'food/流汁汤包/蒸DJI_0050.mp4', alt: '4' }
            
        ];

        const container = document.getElementById('mediaCanvas');

        /*
         * randomBetween 函数解读：
         * 这是一个辅助函数，用于生成指定范围内的随机数。
         * 在 `placeMediaElements` 函数中，它被用来为媒体元素的尺寸、动画持续时间和延迟生成随机值，
         * 使得每个元素的浮动效果看起来更自然、不那么同步。
         */
        function randomBetween(min, max) {
            return Math.random() * (max - min) + min;
        }

        /*
         * placeMediaElements 函数解读：
         * 这个函数负责动态地创建和放置媒体元素到 #mediaCanvas 中。
         * 1. `container.innerHTML = '';`：每次调用时，清空 #mediaCanvas，确保重新渲染。
         * 2. `mediaItems.forEach(...)`：遍历 `mediaItems` 数组中的每个媒体项。
         * 3. `el.classList.add('floating-media');`：为每个创建的元素添加 `floating-media` 类，
         *    这样它就能应用之前定义的 CSS 样式和浮动动画。
         * 4. `baseSize` 的计算：根据媒体类型（视频或图片）生成一个随机的基础尺寸，
         *    你可以调整 `randomBetween` 的参数来控制媒体元素的最小和最大尺寸。
         *    **为了让视频更大并作为视觉重点，视频的 `baseSize` 范围被设置为比图片更大。**
         * 5. 视频属性设置：如果媒体是视频，会设置 `muted` (静音), `loop` (循环播放), `autoplay` (自动播放),
         *    和 `playsInline` (在移动设备上内联播放) 属性。
         *    **同时，视频元素会被赋予更高的 `z-index`，确保它们显示在图片上方。**
         * 6. 动画随机化：`el.style.animationDuration` 和 `el.style.animationDelay` 使用 `randomBetween` 
         *    来为每个元素设置不同的动画持续时间和延迟，这是实现自然浮动效果的关键。
         *    你可以调整 `randomBetween` 的参数来改变动画的快慢和起始时间。
         * 7. `container.appendChild(el);`：将创建并配置好的媒体元素添加到 #mediaCanvas 中。
         * 
         * 如果你想改变媒体元素的尺寸范围、视频播放行为或动画随机化的参数，可以在这里进行修改。
         */
        function placeMediaElements() {
            container.innerHTML = '';

            // 分离视频和图片，确保视频优先显示
            const videoItems = mediaItems.filter(item => item.type === 'video');
            const imageItems = mediaItems.filter(item => item.type === 'image');
            const orderedMediaItems = [...videoItems, ...imageItems];

            orderedMediaItems.forEach((item, index) => {
                const el = document.createElement(item.type === 'video' ? 'video' : 'img');
                el.classList.add('floating-media');
                el.src = item.src;
                el.alt = item.alt;

                let baseSize;
                if (item.type === 'video') {
                    baseSize = randomBetween(280, 380); // 视频尺寸范围更大，可在此处调整
                    el.style.zIndex = '10'; // 视频 z-index 更高，显示在前面
                } else {
                    baseSize = randomBetween(120, 200); // 图片尺寸范围
                    el.style.zIndex = '5'; // 图片 z-index 较低
                }
                el.style.width = `${baseSize}px`;
                el.style.height = 'auto';

                if (item.type === 'video') {
                    el.muted = true;
                    el.loop = true;
                    el.autoplay = true;
                    el.playsInline = true;
                }

                // Randomize animation properties for a natural floating effect
                el.style.animationDuration = `${randomBetween(4, 8)}s`;
                el.style.animationDelay = `${randomBetween(0, 5)}s`;

                container.appendChild(el);
            });
        }

        window.addEventListener('load', () => {
            placeMediaElements();
        });

        window.addEventListener('resize', () => {
            clearTimeout(window.__mediaResizeTimer);
            window.__mediaResizeTimer = setTimeout(placeMediaElements, 200);
        });
    </script>
    <script>
        const particleColors = [0xff6b6b, 0xff2e8f, 0xff9021, 0x94ed5c, 0xfeca57, 0xff9ff3, 0xbaeaa9];
        let scene, camera, renderer;
        let particles;

        function initParticles() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('particle-container').appendChild(renderer.domElement);

            addParticles();

            animateParticles();

            window.addEventListener('resize', onWindowResize, false);
        }

        function addParticles() {
            const particleCount = 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 20;
                positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 20;

                const color = new THREE.Color(particleColors[Math.floor(Math.random() * particleColors.length)]);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.7
            });

            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        function animateParticles() {
            requestAnimationFrame(animateParticles);
            if (particles) {
                particles.rotation.y += 0.0005;
                particles.rotation.x += 0.0005;
            }
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        initParticles();
    </script>
</body>
</html>
